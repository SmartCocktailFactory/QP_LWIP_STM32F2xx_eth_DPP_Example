/*****************************************************************************
* Model: qhsmtst.qm
* File:  ././qhsmtst.c
*
* This file has been generated automatically by QP Modeler (QM).
* DO NOT EDIT THIS FILE MANUALLY.
*
* Please visit www.state-machine.com/qm for more information.
*****************************************************************************/
#include "qep_port.h"
#include "qhsmtst.h"

/* @(/1/0) .................................................................*/
/** 
* Test active object
*/
typedef struct QHsmTstTag {
/* protected: */
    QHsm super;

/* private: */
    uint8_t foo;
} QHsmTst;

/* protected: */
static QState QHsmTst_initial(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s1(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s11(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s2(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s21(QHsmTst * const me, QEvt const * const e);
static QState QHsmTst_s211(QHsmTst * const me, QEvt const * const e);


static QHsmTst l_hsmtst; /* the only instance of the QHsmTst class */

/* global-scope definitions ---------------------------------------*/
QHsm * const the_hsm = (QHsm *)&l_hsmtst;    /* the opaque pointer */

/* @(/1/1) .................................................................*/
void QHsmTst_ctor(void) {
    QHsmTst *me = &l_hsmtst;
    QHsm_ctor(&me->super, Q_STATE_CAST(&QHsmTst_initial));
}
/* @(/1/0) .................................................................*/
/* @(/1/0/1) ...............................................................*/
/* @(/1/0/1/0) */
static QState QHsmTst_initial(QHsmTst * const me, QEvt const * const e) {
    (void)e; /* avoid compiler warning */
    me->foo = 0U;
    BSP_display("top-INIT;");
    return Q_TRAN(&QHsmTst_s2);
}
/* @(/1/0/1/1) .............................................................*/
static QState QHsmTst_s(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1) */
        case Q_ENTRY_SIG: {
            BSP_display("s-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1) */
        case Q_EXIT_SIG: {
            BSP_display("s-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/0) */
        case Q_INIT_SIG: {
            BSP_display("s-INIT;");
            status = Q_TRAN(&QHsmTst_s11);
            break;
        }
        /* @(/1/0/1/1/1) */
        case I_SIG: {
            /* @(/1/0/1/1/1/0) */
            if (me->foo) {
                me->foo = 0U;
                BSP_display("s-I;");
                status = Q_HANDLED();
            }
            else {
                status = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/1/1/2) */
        case E_SIG: {
            BSP_display("s-E;");
            status = Q_TRAN(&QHsmTst_s11);
            break;
        }
        /* @(/1/0/1/1/3) */
        case TERMINATE_SIG: {
            BSP_exit();
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status;
}
/* @(/1/0/1/1/4) ...........................................................*/
static QState QHsmTst_s1(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1/4) */
        case Q_ENTRY_SIG: {
            BSP_display("s1-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/4) */
        case Q_EXIT_SIG: {
            BSP_display("s1-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/4/0) */
        case Q_INIT_SIG: {
            BSP_display("s1-INIT;");
            status = Q_TRAN(&QHsmTst_s11);
            break;
        }
        /* @(/1/0/1/1/4/1) */
        case I_SIG: {
            BSP_display("s1-I;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/4/2) */
        case D_SIG: {
            /* @(/1/0/1/1/4/2/0) */
            if (!me->foo) {
                me->foo = 1U;
                BSP_display("s1-D;");
                status = Q_TRAN(&QHsmTst_s);
            }
            else {
                status = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/1/1/4/3) */
        case A_SIG: {
            BSP_display("s1-A;");
            status = Q_TRAN(&QHsmTst_s1);
            break;
        }
        /* @(/1/0/1/1/4/4) */
        case B_SIG: {
            BSP_display("s1-B;");
            status = Q_TRAN(&QHsmTst_s11);
            break;
        }
        /* @(/1/0/1/1/4/5) */
        case F_SIG: {
            BSP_display("s1-F;");
            status = Q_TRAN(&QHsmTst_s211);
            break;
        }
        /* @(/1/0/1/1/4/6) */
        case C_SIG: {
            BSP_display("s1-C;");
            status = Q_TRAN(&QHsmTst_s2);
            break;
        }
        default: {
            status = Q_SUPER(&QHsmTst_s);
            break;
        }
    }
    return status;
}
/* @(/1/0/1/1/4/7) .........................................................*/
static QState QHsmTst_s11(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1/4/7) */
        case Q_ENTRY_SIG: {
            BSP_display("s11-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/4/7) */
        case Q_EXIT_SIG: {
            BSP_display("s11-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/4/7/0) */
        case H_SIG: {
            BSP_display("s11-H;");
            status = Q_TRAN(&QHsmTst_s);
            break;
        }
        /* @(/1/0/1/1/4/7/1) */
        case D_SIG: {
            /* @(/1/0/1/1/4/7/1/0) */
            if (me->foo) {
                me->foo = 0U;
                BSP_display("s11-D;");
                status = Q_TRAN(&QHsmTst_s1);
            }
            else {
                status = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/1/1/4/7/2) */
        case G_SIG: {
            BSP_display("s11-G;");
            status = Q_TRAN(&QHsmTst_s211);
            break;
        }
        default: {
            status = Q_SUPER(&QHsmTst_s1);
            break;
        }
    }
    return status;
}
/* @(/1/0/1/1/5) ...........................................................*/
static QState QHsmTst_s2(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1/5) */
        case Q_ENTRY_SIG: {
            BSP_display("s2-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5) */
        case Q_EXIT_SIG: {
            BSP_display("s2-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5/0) */
        case Q_INIT_SIG: {
            BSP_display("s2-INIT;");
            status = Q_TRAN(&QHsmTst_s211);
            break;
        }
        /* @(/1/0/1/1/5/1) */
        case I_SIG: {
            /* @(/1/0/1/1/5/1/0) */
            if (!me->foo) {
                me->foo = 1U;
                BSP_display("s2-I;");
                status = Q_HANDLED();
            }
            else {
                status = Q_UNHANDLED();
            }
            break;
        }
        /* @(/1/0/1/1/5/2) */
        case F_SIG: {
            BSP_display("s2-F;");
            status = Q_TRAN(&QHsmTst_s11);
            break;
        }
        /* @(/1/0/1/1/5/3) */
        case C_SIG: {
            BSP_display("s2-C;");
            status = Q_TRAN(&QHsmTst_s1);
            break;
        }
        default: {
            status = Q_SUPER(&QHsmTst_s);
            break;
        }
    }
    return status;
}
/* @(/1/0/1/1/5/4) .........................................................*/
static QState QHsmTst_s21(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1/5/4) */
        case Q_ENTRY_SIG: {
            BSP_display("s21-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5/4) */
        case Q_EXIT_SIG: {
            BSP_display("s21-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5/4/0) */
        case Q_INIT_SIG: {
            BSP_display("s21-INIT;");
            status = Q_TRAN(&QHsmTst_s211);
            break;
        }
        /* @(/1/0/1/1/5/4/1) */
        case G_SIG: {
            BSP_display("s21-G;");
            status = Q_TRAN(&QHsmTst_s1);
            break;
        }
        /* @(/1/0/1/1/5/4/2) */
        case A_SIG: {
            BSP_display("s21-A;");
            status = Q_TRAN(&QHsmTst_s21);
            break;
        }
        /* @(/1/0/1/1/5/4/3) */
        case B_SIG: {
            BSP_display("s21-B;");
            status = Q_TRAN(&QHsmTst_s211);
            break;
        }
        default: {
            status = Q_SUPER(&QHsmTst_s2);
            break;
        }
    }
    return status;
}
/* @(/1/0/1/1/5/4/4) .......................................................*/
static QState QHsmTst_s211(QHsmTst * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/1/0/1/1/5/4/4) */
        case Q_ENTRY_SIG: {
            BSP_display("s211-ENTRY;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5/4/4) */
        case Q_EXIT_SIG: {
            BSP_display("s211-EXIT;");
            status = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/5/4/4/0) */
        case H_SIG: {
            BSP_display("s211-H;");
            status = Q_TRAN(&QHsmTst_s);
            break;
        }
        /* @(/1/0/1/1/5/4/4/1) */
        case D_SIG: {
            BSP_display("s211-D;");
            status = Q_TRAN(&QHsmTst_s21);
            break;
        }
        default: {
            status = Q_SUPER(&QHsmTst_s21);
            break;
        }
    }
    return status;
}

